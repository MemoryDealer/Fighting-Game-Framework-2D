// ================================================ //
// Extreme Metal Fighter
// Copyright (C) 2014 Jordan Sparks. All Rights Reserved.
// Unauthorized copying of this file, via any medium is strictly prohibited
// Proprietary and confidential
// Written by Jordan Sparks <unixunited@live.com> June 2014
// ================================================ //
// File: MUDP.cpp
// Author: Jordan Sparks <unixunited@live.com>
// ================================================ //
// Implements MUDP namespace; Socket class.
// ================================================ //

#include "MUDP.hpp"

// ================================================ //

namespace MUDP{

	// ================================================ //

	Socket::Socket(const int port) :
	m_sock(),
	m_sendBuffer(nullptr),
	m_recvBuffer(nullptr)
	{
		m_sock = SDLNet_UDP_Open(port);
		if (!m_sock){
			throw std::exception("Failed to open UDP socket");
		}

		// Allocate space for 65 KB packets.
		m_sendBuffer = SDLNet_AllocPacket(66560);
		m_recvBuffer = SDLNet_AllocPacket(66560);
	}

	// ================================================ //

	Socket::~Socket(void)
	{
		if (m_sock){
			SDLNet_UDP_Close(m_sock);
		}

		m_sendBuffer->data = nullptr;
		m_recvBuffer->data = nullptr;
		SDLNet_FreePacket(m_sendBuffer);
		SDLNet_FreePacket(m_recvBuffer);
	}

	// ================================================ //

	int Socket::send(Packet* packet, IP& dst)
	{
		m_sendBuffer->address = dst.getAddress();
		m_sendBuffer->data = reinterpret_cast<Uint8*>(packet);
		m_sendBuffer->len = sizeof(Packet)+1;

		return SDLNet_UDP_Send(m_sock, -1, m_sendBuffer);
	}

	// ================================================ //

	int Socket::recv(Packet* packet, IP& src)
	{
		if (SDLNet_UDP_Recv(m_sock, m_recvBuffer)){
			printf("Packet received\n");
			Packet* recvPacket = reinterpret_cast<Packet*>(m_recvBuffer->data);
			// See if this packet was generated by Extreme Metal Fighter.
			if (recvPacket->header == Packet::PROTOCOL_ID){
				src.setAddress(m_recvBuffer->address);
				recvPacket->clone(packet);
				return packet->type;
			}
		}

		return -1;
	}

	// ================================================ //
	// ================================================ //

	IP::IP(const std::string& hostname, const int port) :
	m_address()
	{
		this->resolveHostname(hostname, port);
	}

	// ================================================ //

	IP::IP(void) :
	m_address()
	{

	}

	// ================================================ //

	IP::~IP(void)
	{

	}

	// ================================================ //

	bool IP::resolveHostname(const std::string& hostname, const int port)
	{
		return (SDLNet_ResolveHost(&m_address, hostname.c_str(), port) == 0);
	}

	// ================================================ //
	// ================================================ //

	const Uint32 Packet::PROTOCOL_ID = 666666;

	// ================================================ //

	Packet::Packet(int type) :
	header(Packet::PROTOCOL_ID),
	id(Packet::NIL),
	type(type),
	message()
	{
		static Uint32 idctr = 0;

		id = idctr++;
	}

	// ================================================ //

}

// ================================================ //