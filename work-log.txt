#3/17/14
-The main must have parameters argc and argv for SDL to link properly, not sure if calling main SDL_main is necessary. 
-Got textures loaded; SDL_Texture stores the texture in memory, SDL_RenderCopy() renders the texture and allows specification of 
	coordinates, SDL_QueryTexture() gets a texture's width and height, SDL_RenderPresent() flips the screen, if I understand correctly. 
-SDL_Texture's should be destroyed with SDL_DestroyTexture(),
	same goes for the renderer, and window. 
-Added SDL_image extension, several DLL files are needed (five) for it to work with the executable. 
-Calling IMG_Init() will preload the library to later prevent performance hiccups when using it. 
-Added SDL_ttf library to load true type fonts. 


#3/18/14
-Created git repo and project files. Started building app framework:
	-Log
	-Singleton
	-Engine
	-App, AppStateManager
	-MenuState
-I am using "pointer to implementation" for most classes. 

#3/19/14
-Added Object class, the Engine class now accepts an Object for rendering. 
-Added correct frame time calculations in AppStateManager::start(), although it results in 0.0 per frame with vsync disabled. 

#3/20/14
-Derived Player from Object, along with PlayerImpl from PlayerObject. 
-At first the Player class wouldn't render, until I overrided the getTexturePtr() function. 
	Never mind that, since I redeclared m_pImpl in Player, there were two smart pointers allocated separately. I've removed the allocation in Object and
	added the function Object::setPImpl() which should be called from a derived class. It passes the local private m_pImpl from the child class to the base 
	class and thus the base class m_pImpl points to the child class's m_pImpl. 

#3/24/14
-Added SDLNet in Engine. 
-Added Background object. 
-Getting strange linker error: "Background.obj : error LNK2019: unresolved external symbol "public: __thiscall BackgroundImpl::BackgroundImpl(char const *)" (??0BackgroundImpl@@QAE@PBD@Z) referenced in function "public: __thiscall Background::Background(char const *)" (??0Background@@QAE@PBD@Z)"
	There is also a prior warning: "Debug\BackgroundImpl.obj : warning LNK4042: object specified more than once; extras ignored"
	-Turns out it was a problem with the project file, due to accidently adding BackgroundImpl.cpp in the headers section and changing it to BackgroundImpl.hpp afterwards. There was something in the project file that was confusing the linker, so I just deleted BackgroundImpl.hpp and re-added it properly. 

#3/26/14
-Created ObjectManager, added it to the MenuState. Had to rearrange the destruction of the AppStates and Engine to prevent segfault. 
-Removed Engine::renderObject() and replaced it with Object::render(). This way, the object won't be required to return so many handles. However, the Engine now has to return the SDL_Renderer, but it is a const return value and is casted down in the Object::render() function. 
-Added custom Assert() macro in Engine.hpp, along with static Engine::toString() function. 
-Added a finite state machine object (FSM, uses FState) to be used by whatever needs it. 
-Created PlayerManager singleton, which holds allocates pointers for the RedPlayer and BluePlayer. 
*Was having trouble with getting the player object to render, but I was rendering it before the background. I must remember that z-ordering in the game loop is important. 
-So either the background object should always be added to the ObjectManager first, or it can have its own pointer in the AppState. And the Player objects should be always come last. 

#4/1/14
-Added a timer in the main loop of AppStateManager which limits the maximum frame rate to 60 (a value in Engine). This eliminates the problem with vsync being off. 
-Create Config class for parsing/writing config files. I've given it a basic .ini parser (the function parseValue() will find any value in the ini file). This can be used for most development stuff. 
	Later, it may have a metadata parser and/or a binary parser. 
-Added config file support for basic engine componenets in EngineImpl.cpp (constructor). 
-Re-organized Object constructor to take unsigned int, this way child objects can use enumerated types, such as the Player object taking in the fighter's enumerated type. Then the Player object itself will handle loading the character etc. 
-I've realized that changing the resolution will cause the sprite sizes to be inaccurate, a very big problem for a fighting game. I've tried using SDL_RenderSetLogicalSize() which is supposed to scale things automatically, but I may have to manually
	add scaling because it might be better in the long run. 
-I think I will just use SDL_RenderSetLogicalSize() for now. Later on, to avoid letterboxing, I can set a base value for each aspect ratio and allow a config file to alter the values. http://en.wikipedia.org/wiki/File:Vector_Video_Standards5.svg
	16:9 (1920x1080) is the most common for steam users so I'm working with that. 

#4/2/14
-Added handleInput to AppState class and implemented it in MenuState (GameState will eventually replace these testing stages). Also added processInput() to Player.
-Each character will have their own x-velocity & y-velocity, and max x-velocity/y-velocity. These are set in the .fighter file and are read as the character is loaded.  
*Note that when adding (velocity * dt) to the player position it must be casted to an int, or strange things happen like moving left is twice as fast. 
-Added basic state machine transitions for walking/blocking. 
-Players flip the rendering direction horizontally based on their playerSide variable. 
-Added Animation class, not complete yet as it's being used for testing in the PlayerImpl object. 
-Added Config::parseAnimation() which will find the x1,y1 and x2,y2 values for the animation (i.e. where it starts and where it ends). Other information can be added
	such as repeats and reversals. 

#4/6/14
-Created Move class (actually, it's a struct for simplicity right now). Each PlayerImpl holds a list of Move objects, which are loaded when they are parsed by the FighterMetadata class, which is derived from Config. 
-I've been recreating the sprite sheet for glacius so that it's even by rectangle-selecting a frame in paint.NET and copying it to a new file. Each frame should overlap adjacent frames to there are no png artifacts in the rendering. 
	It seems the very edges of the png file produce artifacts, so using starting x and y coordinates of 1 solves that problem. 
-Added the ability to reverse an animation, so it can go frames 1-5 for example, and then 5-1 and repeat. I thought this might fix the walking animation but it didn't, it may take something more complex like a sequence of three different repeats. 
	This of course depends on the sprite sheet, really. 

#4/7/14
-Added MessageRouter, which holds a global list of pointers to all Objects in the game (across each state). It is a singleton and allows easy communcation between objects, by using their unique object ID. 
	It is initialized and destroyed in App.cpp.
	In the Object's constructor and destructor, it calls MessageRouter to add/remove the object's pointer.
	It is updated automatically in AppStateManager::start().
-Was having issues with holding both left/right and switching between them--the player state would not update correctly and the walking forward animation would play when walking back and vice versa. 
	Fix by adding another transition for states WALKING_FORWARD (WALK_BACK -> WALKING_BACK) and WALKING_BACK(WALK_FORWARD -> WALKING_FORWARD). I previously thought this would be automatically handled
	when the state machine switched back to IDLE since the IDLE state has proper transitions for WALK_BACK and WALK_FORWARD. So each state will need to be completely transitive. 
	This also fixed the issue when switching sides that involved the player state not updating correctly. 
-Since writing all the code for each state added to the state machine will take much time, I can use macros to shorten the code and automate it as much as possible. 
-Created Server object which sets up a basic UDP socket and listens for incoming UDP packets. Tested with UDP Unicorn and it works. 

#4/9/13
-Created Hitbox class. So far it has intersection functions to detect if it intersects with another hitbox and a static function to detect if two hitboxes intersect.
	It also has a render function which will render the hitbox itself (alpha blended with an outline), which the PlayerImpl class can use to show the hitboxes. 

#4/10/13
-Added ability for the FighterMetadata class to parse hitbox data in each frame section. Also modified Move--Frame is now a struct which holds the rect of the frame
	and all corresponding hitboxes. These are then retrieved in PlayerImpl::updateHitboxes() and rendered in the main loop. PlayerImpl now holds a vector of Hitboxes.
-You can now press R to reload all fighter data, so the .fighter file and be edited and the game will reload it on the fly. 
-My hitbox collision function was for hitbox with their origin at the center, where my hitboxes have a top-left origin, lulz. Must fix now. 
-Used LazyFoo's code for rectangle collision, now it works. 
-PlayerManager::update() is currently handling collisions. It sets the m_colliding flag in PlayerImpl when there is a collision. Then in PlayerImpl::update() the player's	
	x velocity is reversed to the maximum upon collision, causing them to bounce off the other player. 

#4/11/13
-Fixed bug in metadata parser (parseMoveValue()). 
-Changed the way hitboxes are handled in PlayerImpl. 
-Added damage box to the WALKING_FORWARD animation to test it, the PlayerManager detects when it collides with any of the opponent's hitboxes. 

#4/12/13
-Replaced Hitbox::intersects() code with SDL_HasIntersection().

#5/8/13
-The reason FighterMetadata::parseMoveIntValue() returns -1 on failure is to let FighterMetadata::parseMove() know if a frame of animation should be inherited
	from the previous frame, rather than assigning its corresponding value(s) to zero. This will no longer be necessary once a tool is developed to visually 
	edit fighter data. 
-Did some basic cleanup of the code. 

#5/12/14
-When backing up the player's x-velocity is multiplied by 0.85 to reduce the speed and make it more realistic. 

#TODO
-Code feels sloppy, clean it up (logging, error handling)
-When colliding make the forward moving player push the other one into a walking back state
-NET
-Background objects should have configuration files just like fighters, with animation data and such
--Replace Background with Stage
-Camera class? 
-LoadResources in Engine
-GUILayer
-use const char* for all string parameters unless an std::string is absolutely necessary. 

#Spreadsheet=https://docs.google.com/spreadsheet/ccc?key=0AnnbWNRHDV25dF9SQy1RWXBYdjBqbklNaDN0U2Rwcnc#gid=0



