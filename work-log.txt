#3/17/14
-The main must have parameters argc and argv for SDL to link properly, not sure if calling main SDL_main is necessary. 
-Got textures loaded; SDL_Texture stores the texture in memory, SDL_RenderCopy() renders the texture and allows specification of 
	coordinates, SDL_QueryTexture() gets a texture's width and height, SDL_RenderPresent() flips the screen, if I understand correctly. 
-SDL_Texture's should be destroyed with SDL_DestroyTexture(),
	same goes for the renderer, and window. 
-Added SDL_image extension, several DLL files are needed (five) for it to work with the executable. 
-Calling IMG_Init() will preload the library to later prevent performance hiccups when using it. 
-Added SDL_ttf library to load true type fonts. 


#3/18/14
-Created git repo and project files. Started building app framework:
	-Log
	-Singleton
	-Engine
	-App, AppStateManager
	-MenuState
-I am using "pointer to implementation" for most classes. 

#3/19/14
-Added Object class, the Engine class now accepts an Object for rendering. 
-Added correct frame time calculations in AppStateManager::start(), although it results in 0.0 per frame with vsync disabled. 

#3/20/14
-Derived Player from Object, along with PlayerImpl from PlayerObject. 
-At first the Player class wouldn't render, until I overrided the getTexturePtr() function. 
	Never mind that, since I redeclared m_pImpl in Player, there were two smart pointers allocated separately. I've removed the allocation in Object and
	added the function Object::setPImpl() which should be called from a derived class. It passes the local private m_pImpl from the child class to the base 
	class and thus the base class m_pImpl points to the child class's m_pImpl. 

#3/24/14
-Added SDLNet in Engine. 
-Added Background object. 
-Getting strange linker error: "Background.obj : error LNK2019: unresolved external symbol "public: __thiscall BackgroundImpl::BackgroundImpl(char const *)" (??0BackgroundImpl@@QAE@PBD@Z) referenced in function "public: __thiscall Background::Background(char const *)" (??0Background@@QAE@PBD@Z)"
	There is also a prior warning: "Debug\BackgroundImpl.obj : warning LNK4042: object specified more than once; extras ignored"
	-Turns out it was a problem with the project file, due to accidently adding BackgroundImpl.cpp in the headers section and changing it to BackgroundImpl.hpp afterwards. There was something in the project file that was confusing the linker, so I just deleted BackgroundImpl.hpp and re-added it properly. 

#3/26/14
-Created ObjectManager, added it to the MenuState. Had to rearrange the destruction of the AppStates and Engine to prevent segfault. 
-Removed Engine::renderObject() and replaced it with Object::render(). This way, the object won't be required to return so many handles. However, the Engine now has to return the SDL_Renderer, but it is a const return value and is casted down in the Object::render() function. 
-Added custom Assert() macro in Engine.hpp, along with static Engine::toString() function. 
-Added a finite state machine object (FSM, uses FState) to be used by whatever needs it. 
-Created PlayerManager singleton, which holds allocates pointers for the RedPlayer and BluePlayer. 
*Was having trouble with getting the player object to render, but I was rendering it before the background. I must remember that z-ordering in the game loop is important. 
-So either the background object should always be added to the ObjectManager first, or it can have its own pointer in the AppState. And the Player objects should be always come last. 

#4/1/14
-Added a timer in the main loop of AppStateManager which limits the maximum frame rate to 60 (a value in Engine). This eliminates the problem with vsync being off. 
-Create Config class for parsing/writing config files. I've given it a basic .ini parser (the function parseValue() will find any value in the ini file). This can be used for most development stuff. 
	Later, it may have a metadata parser and/or a binary parser. 
-Added config file support for basic engine componenets in EngineImpl.cpp (constructor). 
-Re-organized Object constructor to take unsigned int, this way child objects can use enumerated types, such as the Player object taking in the fighter's enumerated type. Then the Player object itself will handle loading the character etc. 
-I've realized that changing the resolution will cause the sprite sizes to be inaccurate, a very big problem for a fighting game. I've tried using SDL_RenderSetLogicalSize() which is supposed to scale things automatically, but I may have to manually
	add scaling because it might be better in the long run. 
-I think I will just use SDL_RenderSetLogicalSize() for now. Later on, to avoid letterboxing, I can set a base value for each aspect ratio and allow a config file to alter the values. http://en.wikipedia.org/wiki/File:Vector_Video_Standards5.svg
	16:9 (1920x1080) is the most common for steam users so I'm working with that. 

#4/2/14
-Added handleInput to AppState class and implemented it in MenuState (GameState will eventually replace these testing stages). Also added processInput() to Player.
-Each character will have their own x-velocity & y-velocity, and max x-velocity/y-velocity. These are set in the .fighter file and are read as the character is loaded.  
*Note that when adding (velocity * dt) to the player position it must be casted to an int, or strange things happen like moving left is twice as fast. 
-Added basic state machine transitions for walking/blocking. 
-Players flip the rendering direction horizontally based on their playerSide variable. 
-Added Animation class, not complete yet as it's being used for testing in the PlayerImpl object. 
-Added Config::parseAnimation() which will find the x1,y1 and x2,y2 values for the animation (i.e. where it starts and where it ends). Other information can be added
	such as repeats and reversals. 

#4/6/14
-Created Move class (actually, it's a struct for simplicity right now). Each PlayerImpl holds a list of Move objects, which are loaded when they are parsed by the FighterMetadata class, which is derived from Config. 
-I've been recreating the sprite sheet for glacius so that it's even by rectangle-selecting a frame in paint.NET and copying it to a new file. Each frame should overlap adjacent frames to there are no png artifacts in the rendering. 
	It seems the very edges of the png file produce artifacts, so using starting x and y coordinates of 1 solves that problem. 
-Added the ability to reverse an animation, so it can go frames 1-5 for example, and then 5-1 and repeat. I thought this might fix the walking animation but it didn't, it may take something more complex like a sequence of three different repeats. 
	This of course depends on the sprite sheet, really. 

#4/7/14
-Added MessageRouter, which holds a global list of pointers to all Objects in the game (across each state). It is a singleton and allows easy communcation between objects, by using their unique object ID. 
	It is initialized and destroyed in App.cpp.
	In the Object's constructor and destructor, it calls MessageRouter to add/remove the object's pointer.
	It is updated automatically in AppStateManager::start().
-Was having issues with holding both left/right and switching between them--the player state would not update correctly and the walking forward animation would play when walking back and vice versa. 
	Fix by adding another transition for states WALKING_FORWARD (WALK_BACK -> WALKING_BACK) and WALKING_BACK(WALK_FORWARD -> WALKING_FORWARD). I previously thought this would be automatically handled
	when the state machine switched back to IDLE since the IDLE state has proper transitions for WALK_BACK and WALK_FORWARD. So each state will need to be completely transitive. 
	This also fixed the issue when switching sides that involved the player state not updating correctly. 
-Since writing all the code for each state added to the state machine will take much time, I can use macros to shorten the code and automate it as much as possible. 
-Created Server object which sets up a basic UDP socket and listens for incoming UDP packets. Tested with UDP Unicorn and it works. 

#4/9/13
-Created Hitbox class. So far it has intersection functions to detect if it intersects with another hitbox and a static function to detect if two hitboxes intersect.
	It also has a render function which will render the hitbox itself (alpha blended with an outline), which the PlayerImpl class can use to show the hitboxes. 

#4/10/13
-Added ability for the FighterMetadata class to parse hitbox data in each frame section. Also modified Move--Frame is now a struct which holds the rect of the frame
	and all corresponding hitboxes. These are then retrieved in PlayerImpl::updateHitboxes() and rendered in the main loop. PlayerImpl now holds a vector of Hitboxes.
-You can now press R to reload all fighter data, so the .fighter file and be edited and the game will reload it on the fly. 
-My hitbox collision function was for hitbox with their origin at the center, where my hitboxes have a top-left origin, lulz. Must fix now. 
-Used LazyFoo's code for rectangle collision, now it works. 
-PlayerManager::update() is currently handling collisions. It sets the m_colliding flag in PlayerImpl when there is a collision. Then in PlayerImpl::update() the player's	
	x velocity is reversed to the maximum upon collision, causing them to bounce off the other player. 

#4/11/13
-Fixed bug in metadata parser (parseMoveValue()). 
-Changed the way hitboxes are handled in PlayerImpl. 
-Added damage box to the WALKING_FORWARD animation to test it, the PlayerManager detects when it collides with any of the opponent's hitboxes. 

#4/12/13
-Replaced Hitbox::intersects() code with SDL_HasIntersection().

#5/8/13
-The reason FighterMetadata::parseMoveIntValue() returns -1 on failure is to let FighterMetadata::parseMove() know if a frame of animation should be inherited
	from the previous frame, rather than assigning its corresponding value(s) to zero. This will no longer be necessary once a tool is developed to visually 
	edit fighter data. 
-Did some basic cleanup of the code. 

#5/12/14
-When backing up the player's x-velocity is multiplied by 0.85 to reduce the speed and make it more realistic. 
-Removed Background class and replaced it with the more versatile Stage class. It holds a list of StageLayer's which hold a texture and any effect data. The stage layers
	are rendered in order, with layer 1 being behind all succeeding layers. 

#5/13/14
-Added StageManager which is a singleton and keeps stage management more organized and clean. 
-Re-organized PlayerManager to stay consistent with StageManager.
-Added GameState and put all the game code so far into it. MenuState allocates PlayerManager and StageManager, etc. 
-Modified MenuStateImpl's constructor to take a pointer to MenuState, so AppState::pushAppState() and AppState::popAppState() can be accessed from within MenuStateImpl.
	Also had to modify the access of those functions in AppState.hpp from protected to public. This will also be done for succeeding states. 

#5/26/14
-Replaced many uses of const char* in function parameters with const std::string&. I will do this wherever possible to keep the use of std::string consistent. When the time
	comes to integrate other languages this will make it much easier. 
-Added reload() function to PlayerManager and StageManager. 
-Created Camera class which does basic left/right scrolling. It only holds values for where the camera is moving, and StageImpl::update() uses those values to move. 

#5/27/14
-Upgraded to Visual Studio 2013 Ultimate and have C++11. So all std::tr1::shared_ptr<>'s are now std::shared_ptr<>. 
-Put camera movement code in PlayerManager::update(). For now, I will just have to manually check each player according to their side to find out if the camera
	moves. Organizing this in some "correct" manner has proven confusing. 
-Previously the m_colliding value was set to false after collisions were handled in PlayerImpl::update(). It is now reset in PlayerManager::update() right before
	collisions are tested between normal hitboxes. This allows camera movement to be processed for when one player is pushing the other past the edge. 
-Hard coded the starting positions for the players. There is no longer a need for the game.cfg file and it is in the process of being terminated. 
-Also removed network.cfg and just created a [net] section in engine.cfg. 
-In PlayerManager::update(), moved the code to update both players to the beginning of the loop, so that the velocity will be updated before the following code uses it. 
-Got proper camera movement for red player moving left. The blue player's position is manually adjusted in PlayerManager::update() so that he stands still, rather than moving
	with the camera. This may be cheap but it works for now. 

#5/28/14
-Updated Camera class to use proper getter/setter functions. 
-Added PlayerManager::updateCamera() and moved most of the code from update() to it and removed a few unnecessary std::abs() calls. 
-Added Player::toggleDrawHitboxes(). 
-Made the stage start in the exact middle rather than the far right side. 
-The converted project from Visual Studio 2010 was linking very slowly (7-10 seconds). Tried changing many options to no avail. Created a brand new project in 
	Visual Studio 2013 and added all files and builded; now it's extremely fast. Linking time is less than a second.
-Added command line option "/NODEFAULTLIB:msvcrt.lib" in Linker section of project properties. This removed the warning "warning LNK4098: defaultlib 'msvcrt.lib' conflicts with use of other libs; use /NODEFAULTLIB:library"
-So the actual cause of the long linking times was the /FR option being set from generating the dependency graph. It can be disabled by going to Project Properties->C/C++->All Options->Enable Browse Information=No.
	Still, the new 2013 project is much more clean and efficient. 

#5/30/14
-Added Game singleton class to manage information across all states. 

#5/31/14
-Added Widget class for GUI widgets.
-Subclassed Widget to create a Button.
-Was considering creating a totally modular GUI system (run completely by config files), but I think it's way too much work for this project. GUI layers for each
	state will be hard-coded, yet still customizable through config files (textures, positions, etc).  
-Created GUI and GUILayer class. The GUI class is abstract and holds a dynamically sized list of GUILayer's. It is subclassed for each state's GUI. 
-Create GUIManager singleton to allocate and hold each GUI per state. 
-Added mouse hovering detection for GUI. 

#6/1/14
-Added offset value to Label class. This "squeezes" the text inward by equal values on both sides, so it may render more neatly. Can be specified in .gui file. 
-Ran into a cumbsersome error, took some time to figure it out. In GUIMenuState's constructor I tried to call Button::setLinkID() but it crashed in Widget.cpp, saying
	m_pImpl was empty. Due to two layers of inheritance, the Widget's m_pImpl was null, so I had to override setPImpl() from Object and call Widget::setPImpl() in 
	Button's constructor all three layers would point to the implementation. This is getting clustered and I may consider removing the PImpl idiom from widgets. 
	This can also be circumvented by allocated WidgetImpl in Widget's constructor, however this means that Widget and Button point to two separate locations in memory.
	I don't know if this will work, further testing must be conducted within these deep, dark chambers. 
-Got the GUI selector working. Pressing the arrow keys will switch the GUI in selector mode, and they can be used to navigate the menu. This will be useful for controller
	input as well.
	
#6/2/14
-When trying to allocate a GUI in MenuState's constructor, I forgot the constructor is called in App.cpp before FontManager is allocated, so it couldn't find a font.
	Solution is to allocate the FontManager right after the engine, before app states are created. 
-_CRT_SECURE_NO_WARNINGS has been defined in project preprocessor settings to allow for use of strtok(). 
-Links for widgets are parsed from the .gui file using Widget::parseLinks(), a helper function. 
-Optimized the layer loading code for a GUI--created a template function GUILayer::parse() which takes the widget type and a vector of names for each widget. This
	reduced the loading code from ~30 lines to just a few. Quite beautiful, I am satisfied. A template function must be explicitly instantiated for each type of widget
	below the actual definition of GUILayer::parse() in GUI.cpp, for proper linking to occur. 
-In AppStateManager::start()'s update loop (this is the main game loop), add a line to set the render color to black before updating the MessageRouter and active state. 
	This will ensure that any background not covered by a texture(needed for the letterboxing that occurs on certain resolutions) will be black. 
-Used m_quit in MenuState to properly exit. Before, after calling m_pMenuState->popAppState() the MenuStateImpl::update() loop would still run. 

#6/11/14
-Changed GUI's static strings to smart pointers of SDL_Texture. This way the button's textures (and other widgets eventually) can be swapped without having to reload
	textures. Note each smart pointer allocate assigns SDL_DestroyTexture() as the custom deleter. 
-Added Object::setTexture() which takes a raw SDL_Texture pointer or a smart pointer (overloaded) to assign the Object's texture. It also sets default coordinates. 
-Removed GUI::renderSelector(), now everything is handled in GUI::setSelectedWidget().
-Apparently calling Widget::setPImpl() and Object::setPImpl() in Button's constructor is the correct way of setting multiple layers of pImpls. 
-In MenuStateImpl, when the campaign button is pressed, the game state is pushed onto the stack. When it is popped and menu state runs, the old mouse coordinates are still there,
	and the campaign button still appears selected even if the mouse is not hovering over it. To remedy this for now, I've set the mouse coordinates to (-1, -1) before pushing the 
	game state. 
-Added ability for buttons to change their appearance as the mouse button is held down. It stays if the button is held and the mouse is moved elsewhere, just like a normal GUI for an OS, etc.
	Quite elegant. Also works for keyboard. 

#6/12/14
-Created Input class, which is held by each PlayerImpl. This holds the states of all input buttons and an input map. 

#6/13/14
-Tested Xbox360 controller input, works nicely. 
-The gamepad and keyboard controls can be used simultaneously. 
-Added controller support in both game state and menu state.
-Button maps are loaded from .bmap files, which hold both keyboard and gamepad mappings. The player will be able to save/load button maps using these. 
-When removing a controller, the SDL_GameController pointer in the Player's Input object is set to nullptr, however something weird happens with the memory
	and when I tried to add the controller back it would get IDs confused. I fixed this by assigning nullptr to the Player of which the controller was removed. 
-I've extensively tested plugging in and unplugging two xbox360 controllers, alternating them every which way and I experience no errors in controlling the players. 

#6/14/14
-Added ability to navigate main menu with left joystick on xbox360 controller. Should work with any compatible gamepad's default joystick. In the handleInput() code,
	I use to static booleans (xAxisReset & yAxisReset) to force the joystick to be re-centered before it can navigate again in the same direction. This way, it doesn't 
	just speed over all the widgets in the GUI. 
-Added a movement mode (JOYSTICK or DPAD) to the Input class. This prevents the joystick from interfering with dpad movement if the player is using the dpad. This is all 
	automated so the player won't have to deal with it.
-Optimized the handleInput() function in GameState so that it doesn't have to check both the red and blue player objects separately. It just gets a pointer to the player
	being controlled by the gamepad. I don't know why I didn't think of this before. 

#6/16/14
-Added static version numbers to Engine. Should be changed as needed. 
-Added Engine::setResolution() which simply calls SDL_SetWindowSize(). 
-Prevented the mouse from selecting one button, hovering to another, and releasing the mouse button and selecting the new button. This is done by storing the value
	of the last selected widget in processGUIAction() and checking the currently selected widget on GUI::Action::FINISH_PRESS. 
-Found a GUI bug where moving the mouse left/right over two buttons could result in a button that is not selected appear as selected. To quickly fix this, I instead
	set all widgets to an idle appearance when the mouse is not hovering over any instead of just the previously selected widget. 

#6/18/14
-All code is undergoing extreme documentation using a consistent commenting style. 
-Using this template for every file:
	// ================================================ //
	// Extreme Metal Fighter
	// Copyright (C) 2014 Jordan Sparks. All Rights Reserved.
	// Unauthorized copying of this file, via any medium is strictly prohibited
	// Proprietary and confidential
	// Written by Jordan Sparks <unixunited@live.com> June 2014
	// ================================================ //
	// File: 
	// Author: Jordan Sparks <unixunited@live.com>
	// ================================================ //
	// 
	// ================================================ //

#6/20/14
-There was a bug where players would move by themsevles when left still sometimes. I multiplied dt by 10 in PlayerManager::update() in the game loop, which sped 
	up the game clock for the players by a magnitude of 10. It was quite apparent that they were moving on their own with the game clock sped up, so I isolated the 
	bug to the deceleration code in PlayerImpl::updateLocalInput(). I simply was not checking if the difference from the deceleration calculation overshot zero. It has been fixed. 

#6/23/14
-Removed Pimpl idiom for Object and all of its derived classes, as well as GameState/MenuState. It was too cumbersome for a polymorphic class and should 
	only be used for classes that won't be inherited from.
-Added some more documentation among the code.

#6/27/14
-Intellisense in Visual Studio 2013 incorrectly shows errors when including SDL headers in stdafx.hpp when I use the environment variable %SDL% ("D:\SDL2") in the additional include directories 
	for the project options. If I manually put "D:\SDL2\include" instead of "%SDL%\include" it's fine. So until this bug in VS2013 is fixed, I must hard code the SDL directory.
-Added some more documentation.

#6/29/14
-Added some more documentation to the files. Almost done.
-Added PlayerManager::reset() which loads both Player objects using empty filenames. Player's constructor catches the empty file name and stops loading it. This allows the MenuState to pre-load
	button maps so users can navigate the menus.
-Finished documenting every file.
-Got several crashes when clicking randomly in the main menu. Perhaps there is a bug in the GUI handling.

#7/5/14
-Added Input::SDLButtonToMappedButton() which takes the SDL_Event cbutton.button value and finds the corresponding Input button value according to 
	the button map. This removes the need for long if-else chains in state code.
-Added ability for Config::parseValue() to parse values inside quotation marks. The parameter quotations must be set to true.
-Changed m_file >> buffer to std::getline(m_file, buffer) inside Config::parseValue().
-For some reason the .bmap files only had carriage returns (CR) and not CRLF like other files. Perhaps it has to do with how they were created. I created 
	new ones in Notepad++ and now they have CRLFs.

#7/8/14
-Added layer stack to GUI class, which keeps all of the active GUILayers. Can be pushed and popped through GUI::pushLayer() and GUI::popLayer().
-In Object::render()'s 2nd call to SDL_RenderCopyEx(), I changed the destination rect pointer to nullptr, otherwise an Object without a core texture
	would fail to render the text because the src rect is zero.
-Added Static Widget which holds text for now. Can be modified to hold a picture as well.
-Added Textbox Widget, working on using SDL_TEXTINPUT to allow text input.
-Added a cursor to the Textbox Widget. It only stays at the end for now.
-Created logic for activating the Textbox Widget and editing the text, and exiting editing mode. These are handled in GUI and in the AppState.

#7/14/14
-Added style value to Widget class, styles can be set much like Win32 controls. Tested it with TB_NUMBER (meaning Textbox number only). So if a Textbox
	widget has the style TB_NUMBER, then it can only accept number values.
	The style is parsed from the .gui file when added to the layer. A style value of zero is the DEFAULT style.

#7/17/14
-Added GUITheme singleton class which holds all the theme texture pointers publicly.
-Fixed bug where more than one widget would change its appearance to selected if the mouse moved quickly enough over them.
-Added listbox which displays chat.

#7/18/14
-Added ability to wrap text in Label::create() by specifying in the parameter wrap the size in pixels at which the text should be wrapped.
-Widgets can now specify their own font according to the .gui file.
-Textboxes can scroll left/right, however it is currently messed up and the original string (m_text in WidgetTextbox) gets modified somehow during setLabel(). 

#7/22/14
-Wasted a few hours trying to figure out why m_text was being changed in WidgetTextbox, it was due to calling this->setLabel() in handleEditing(), which assigned m_text to the 
	label parameter. I changed it to Object::setLabel() to fix it.
-Modified WidgetTextbox::setLabel() to allow longer strings than the width of the textbox, it will now scroll to the end of the string automatically.

#7/23/14
-Added Client and Server code. Basic connection working.
-Before operating on m_packet in the Client/Server, I memset it to zeroes since the Packet object it points to is allocated on the stack(for speed) and no longer 
	exists during the next attempted operation.

#7/24/14
-Got basic client-to-server chat working however I'm not pleased with how I must allocte a copy of the Packet in Server::update() and return it to LobbyState::update(). This kind
	of heap allocation can cause a lot of overhead and I should find an alternative.

#7/28/14
-Added static function Packet::send() to reduce code size in client and server.
-Changed the Packet struct to use a char array rather than std::string for simplicity of sending it over a network.

#7/29/14
-I was previously using a single packet buffer (UDPpacket*) for both sending and receiving on the client and server. This was causing a memory interference, so 
	I now use two packet buffers; one for sending and one for receiving. Crashes no longer seem to occur.
-Created a Packet smart pointer in LobbyState which is passed into the Server, which the server stores. When a packet is received and
	processed, it is copied to this stored pointer in the Server code using Packet::clone(), thus eliminating the new to use heap allocation
	during the Server update. The same will be done for the client code.
-Added username textbox in Host/Join GUIlayers. Also a password field for future.
-The username is retrieved when the Client/Server is started and stored in Game.

#7/30/14
-Added more broadcasting from the server to clients (for new connected clients and disconnections).
-Added disconnection detection for client and server.

#7/31/14
-Removed Packet header and source files and created MUDP(Metal UDP) class. It is not fully working as of now, and I'm still considering
	the possibility of using TCP but I think it's unlikely, as the latency would be a big issue over the Internet.

#8/21/14
-Removed old netcode and compiled RakNet to use with ExtMF. I've added basic client/server code using RakNet. This is the better option
	to ensure reliability and ordered arrival of UDP packets. 

#8/22/14
-Previously I was broadcasting ID_DISCONNECTION_NOTIFICATION to all other clients from the server when one client disconnected, this
	caused all the clients to be disconnected, so I must use a separate ID, which I have created in NetMessage.hpp.

#8/25/14
-Added username checking on the server to avoid duplicates.
-Added a player listbox which lists all currently connected players by their username on both the server and client. It is updated when a player connects or 
	disconnects, and when a new client connects the whole list of usernames is sent to them.
-Added Message box layer to the GUI class. It is a GUILayer call GUILayerMessageBox and has the index of zero in the GUI class by default. So any other layers
	added to a GUI must start at index 1. The message box can be shown by calling GUI::showMessageBox(true), in which the previous layer will be partially blacked
	out but still rendered, while the message box layer is rendered on top.

#8/26/14
-Added border to the listbox, which is just another texture pointer. The offset from the border is calculated in the render() function.
-Created a "ready queue" in the server. Whenever a client or the server clicks the ready button, they are added to the ready queue. Matches will play out in 
	the order of those in the ready queue, each subsequent player facing the previous victor (at least in default mode). Eventually the player will select which
	fighter they are using before clicking ready.
-Added a start button in the lobby state, which calls Server::startGame(), which lets all the clients know the game is starting and tells the clients which ones
	are playing.

#8/27/14
-Deleted Player class code, restarted. Right now it just renders a green box. I may remove the "player action" feature and just use the state machine directly
	so that networked state changes work properly. Updating the position on the client from the server was very choppy, and on localhost, too. Updating the velocity
	and acceleration, then the position helps a lot with the choppiness. It does however still stutter at times, I will need to experiment more to get fluid motions
	on the client that's playing, because something is different from the way the movement is calculated, perhaps teh game clocks being run at different tiems.
	A timestamp feature in RakNet may prove useful for this.
-Added reliability parameter for network sending functions to allow more control.

#8/28/14
-Tested a better network position update.

#8/29-31/14
-Messed with networking code for latency compensation, referencing http://www.gabrielgambetta.com/fpm2.html
-Got something close to working, still laggy.

#9/1/14
-I have working server reconciliation (e.g., the client input is immediately responsive and is corrected by the server as needed), however it jumps randomly sometimes,
	and I think it has to do with unprocessed inputs for some reason still being in the queue even though the server has processed them.

#9/5/14
-Added network latency simulation variables to Game to more easily change simulation.

#9/7/14
-Moved ExtMF.cfg into Data folder and added config.ini which holds the relative path to ExtMF.cfg. This is useful for testing netcode, since I only have to edit
	a single ExtMF.cfg file instead of changing both the Visual Studio working directory version and the Debug/Release directory version.
-If receiving a "error LNK2005" linker error, make sure the associated function is either inline or in the .cpp file.
-Fixed the teleporting problem when immediately switching from moving right to left and vice versa. Was caused by applying rewinded input using the current
	x-velocity, so now it's calculated using the rewinded input's x-velocity.
-I have mixed up Game::getState() and Game::getMode(), the two words are very similar so I am making a change to this system.
-Enabled blue player client-side code.

#9/8/14
-Game state can now be pushed again after the first time, had to call reset() on the state when resuming lobby state.
-The player list is updated when resuming lobby state to account for disconnections.
-Added Yes/No box to GUI, it is processed using Game's Error code.
-Created GUIGameState.
-Added WidgetHealthBar to display each player's health.

#9/9/14
-Added Config::parseColor(), added color parsing for labels in GUI.

#9/11/14
-PlayerManager stores index of fighter that was loaded instead of the filename. It is used to retrieve the fighter name for displaying in the 
	game state GUI.
-Simulating packet loss may not be necessary, as that is the user's problem.

#9/12/14
-The deceleration code in Player was causing a jump in the client when switching directions, as well is shaking in the client when standing still.
	I've changed it to just set the player's x velocity to zero immediately when neither left or right is pressed, it behaves better.
-It looks pretty smooth with an x-acceleration of 50, but also works well with 150, which is basically instantaneous. 

#9/15/14
-Added back sprite rendering to Player class. This time it is simplified and I will build it more cleanly from the ground up. Added the state variable to
	Server::PlayerUpdate, so when a client receives the update it will automatically update the non-player to the recent state.
	The Player that is being played on the client has its state updated in Player::serverReconciliation() from the most recent update. Not sure if this will be  
	necessary but I am doing it for now.
-Added Player::takeDamage() which subtracts from the hp and modifies the health bar. The server processes damage box collisions and broadcasts any damage to the clients.

#9/18/14
-Redesigned the config file relative paths, all paths should now use the relative path from the "Data" directory. So a .gui file should be 
	specified in ExTMF.cfg as "GUI/file.gui". When file locations are parsed it should be done by first retrieving the location of the 
	Data directory (specified in config.ini in the same directory as executable and stored in Engine object) by calling 
	Engine::getDataDirectory() and adding the rest of the path, including the "/" in between directories if it is not specified in the 
	config file relative path.

#9/20/14
-Added basic stage shifting (the background scrolls left/right as players move to edge) support for netplay. With lag simulation, the client is choppy, so I will
	have to add client-side prediction with server reconciliation for stage shifting as well.

#9/22/14
-Implemented stage shift client-side prediction and server reconciliation, e.g., when the client moves in such a way that the stage view shifts left/right, the
	client will predict how it should move and upon receiving updates from the server, it will rewind to the shift position the server sends (which is from the past),
	and re-apply unprocessed stage shift events so that the movement is seamless, assuming no packet loss.
-Also added playerShift so that the actual adjustment of the opposing player when the stage is shifting is also predicted, leaving no delay.
-Added basic collision. With lag, the client can pass through the other player, due to the replayed pending inputs I believe. Perhaps I can add a check for collision
	before replaying.

#9/27/14
-Added some basic jumping code. 
-Removed setting the state directly when updating the client with server update. It may not be necessary to do so. May need to add some kind of client side
	move predictor.

#9/28/14
-Improved jumping code. However, there are issues with client side prediction on ping > 50ms or so. The client is choppy and moves around too much. Also, there
	is input lag when jumping; the animation starts but it takes n ms for the client to actually start jumping. I believe this is happening because the jump movement
	is not being saved in the pending inputs and thus not being replayed. One solution may be to have a second list of movements to replay for things like jumping.
-Started using the state machine for player state transitions.
-Added crouching code. It seems to work fine, although the uncrouching animation may be a little choppy, however it could be caused by the shitty sprite clipping coordinates
	I have in place right.
-Added light punch move. The sprite clipping is off so the rendering size is not accurate, however it works. It transitions into IDLE.
-Added basic hitstun state, it is set in Player::takeHit(). PlayerManager's update loop gets the attacking player's move damage and hitstun and calls Player::takeHit().

#9/29/14
-Enabled local play, will need to add specialized local lobby when needed.
-Fixed frame locking glitch where if LP input was held down the move would stop at the last frame (I directly transition to the next move when it's done).
-Added "reactivated" state of buttons, this is used to prevent a player from holding down a button and repeating a move. This may also be useful for cancels.
-Jumping is now frame rate independent, I use a sine calculation from 0 to PI for perform the jump.
-I seem to have eliminated the problem of the client being able to do a LP right after landing a jump or during a jump by not calling Player::processInput()
	during serverReconciliation() replaying of pending inputs. I will need to either create a function specifically to replay pending inputs, or I could try
	storing the entire Input state of each pending input and restoring it temporarily for processing.
-Also stage shift prediction stopped working at some point and I don't know when, so fuck me.

#9/30/14
-Temporarily disabled stage shift prediction.
-The rendering adjustment for the m_dst rect on the right side during LP stopped working on the client at some point, don't know what caused it.
	It was being caused by updating the client's position directly during serverReconciliation(). Now I filter out the updates based the update state,
	and don't allow direct updates during ATTACK_LP. 
-Added network tick rate variable to server class, it is parsed from ExtMF.cfg and calculated to milliseconds (Server sends out updates every n milliseconds).
-Added game clock modification ability using Engine::setClockSpeed(). Holding down tab slows down the game to 20% speed currently, also incorporated the game 
	clock into the timer class. The attacking LP animation extends out too far when the clock is slow and jumping is not as far.
-I determined that the snaps occurring after landing a left/right jump on the client were being caused by reapplying old server updates, since all of
	server reconciliation is temporarily paused while in the air to maintain the illusion of perfect synchronization (it will however process for special
	server updates such as hits during jumping). 
	So to solve this I store the client input sequence number at the moment of transitioning into the jump state, and when processing server updates, each
	update's lastProcessedInput value is check if it is <= the client input sequence number at the time of jumping. If so, it is discarded as old. Protection
	is also done for important updates such as hits, since the update's state is checked before doing this operation.

#10/1/14
-Applied the game clock speed to animation updates of the m_dst rect in Player from specific frames. This fixes the slow motion rendering to be the same as normal
	speed. This will make debugging easier.

#10/2/14
-The rw and rh values for each frame of a move are generated automatically now based on the previous frame's width and height. For the first
	frame, if no rw or rh are specified, they are set to zero.

#10/10/14
-Added STUNNED_BLOCK move which works just like STUNNED_HIT but shows the blocking animation.
-Updated Player::takeHit() to process blockstun and hitstun depending on the player state.
-Added Server::broadcastHitBlock() which tells clients a player is blocking a hit.
-Made a better collision system. It's choppy when the player jumps on top of the other, however. I'm sure there is a way to fix this with
	some interpolation or something.

#TODO
-Fix stage shifting prediction!
-When player who is jumping is hit, they stay standing in midair--they need to finish the jump or get knocked down.
-Organize player processing and update functions better, there is redundancy.

-Need to move all update() functions above getter/setter functions in header files for consistency.
-Encountered a vector subscript out of bounds error that is no teasily reproducable, occurred on the server with two clients when the client player was
	colliding with the server player. It may be a good idea to go through every instance of vector code and add bounds checking.
-Add ability to select an entry in listbox if enabled.
-add offsets in themes for text
-Create a component to add to each state that handles duplicate procedures
-Add more bounds checking in GUI functions, getting lots of vector out of bounds errors.
-Add an on-screen keyboard for selector mode during text editing. It should render on top of the current layer.
	Make Textbox scroll left/right for longer strings. Add multiline style.
-Add the ability for the GUI to enable/disable interaction, use when processing data.
-Explicitly define copy constructor and copy assignment operator for all classes.
-Create a "cache" of textures (and maybe other SDL data) which are pointers to loaded textures. Can hold the name of the file, which can be
	checked before a texture is loaded again. If it's in the cache, a pointer is just retrieved from it.
-Check for ExtMF.cfg in the working directory on startup. If it's not there, generate a default one and notify the user.
-Consider removing copied code (such as event handling for controller devices added/removed) to its own file to call from both game state and menu state.
-Use SDL_UpdateTexture() to change colors of textures on the fly
-Remove c_str() on std::strings where feasible
-When colliding make the forward moving player push the other one into a walking back state
-LoadResources in Engine
-For release builds enable code optimization in Project Options->C/C++->Optimization
-For net security: http://www.raknet.net/raknet/manual/secureconnections.html

#BUGS
-serious problems with GUI reloading textures between states, something weird with GUILayer::parse() perhaps.
-If holding down a movement key when exiting game state, the key is still registered as down when returning. This may resolve itself once PlayerManager
	is re-allocated per entry to game state. 
-When unplugging an xbox360 controller, it sends input from seemingly random buttons. 
-When clicking the campaign button more after it's already pressed, an abort() error occurs.

#Spreadsheet=https://docs.google.com/spreadsheet/ccc?key=0AnnbWNRHDV25dF9SQy1RWXBYdjBqbklNaDN0U2Rwcnc#gid=0



