#3/17/14
-The main must have parameters argc and argv for SDL to link properly, not sure if calling main SDL_main is necessary. 
-Got textures loaded; SDL_Texture stores the texture in memory, SDL_RenderCopy() renders the texture and allows specification of 
	coordinates, SDL_QueryTexture() gets a texture's width and height, SDL_RenderPresent() flips the screen, if I understand correctly. 
-SDL_Texture's should be destroyed with SDL_DestroyTexture(),
	same goes for the renderer, and window. 
-Added SDL_image extension, several DLL files are needed (five) for it to work with the executable. 
-Calling IMG_Init() will preload the library to later prevent performance hiccups when using it. 
-Added SDL_ttf library to load true type fonts. 


#3/18/14
-Created git repo and project files. Started building app framework:
	-Log
	-Singleton
	-Engine
	-App, AppStateManager
	-MenuState
-I am using "pointer to implementation" for most classes. 

#3/19/14
-Added Object class, the Engine class now accepts an Object for rendering. 
-Added correct frame time calculations in AppStateManager::start(), although it results in 0.0 per frame with vsync disabled. 

#3/20/14
-Derived Player from Object, along with PlayerImpl from PlayerObject. 
-At first the Player class wouldn't render, until I overrided the getTexturePtr() function. 
	Never mind that, since I redeclared m_pImpl in Player, there were two smart pointers allocated separately. I've removed the allocation in Object and
	added the function Object::setPImpl() which should be called from a derived class. It passes the local private m_pImpl from the child class to the base 
	class and thus the base class m_pImpl points to the child class's m_pImpl. 

#3/24/14
-Added SDLNet in Engine. 
-Added Background object. 
-Getting strange linker error: "Background.obj : error LNK2019: unresolved external symbol "public: __thiscall BackgroundImpl::BackgroundImpl(char const *)" (??0BackgroundImpl@@QAE@PBD@Z) referenced in function "public: __thiscall Background::Background(char const *)" (??0Background@@QAE@PBD@Z)"
	There is also a prior warning: "Debug\BackgroundImpl.obj : warning LNK4042: object specified more than once; extras ignored"
	-Turns out it was a problem with the project file, due to accidently adding BackgroundImpl.cpp in the headers section and changing it to BackgroundImpl.hpp afterwards. There was something in the project file that was confusing the linker, so I just deleted BackgroundImpl.hpp and re-added it properly. 

#3/26/14
-Created ObjectManager, added it to the MenuState. Had to rearrange the destruction of the AppStates and Engine to prevent segfault. 
-Removed Engine::renderObject() and replaced it with Object::render(). This way, the object won't be required to return so many handles. However, the Engine now has to return the SDL_Renderer, but it is a const return value and is casted down in the Object::render() function. 
-Added custom Assert() macro in Engine.hpp, along with static Engine::toString() function. 
-Added a finite state machine object (FSM, uses FState) to be used by whatever needs it. 
-Created PlayerManager singleton, which holds allocates pointers for the RedPlayer and BluePlayer. 
*Was having trouble with getting the player object to render, but I was rendering it before the background. I must remember that z-ordering in the game loop is important. 
-So either the background object should always be added to the ObjectManager first, or it can have its own pointer in the AppState. And the Player objects should be always come last. 

#4/1/14
-Added a timer in the main loop of AppStateManager which limits the maximum frame rate to 60 (a value in Engine). This eliminates the problem with vsync being off. 
-Create Config class for parsing/writing config files. I've given it a basic .ini parser (the function parseValue() will find any value in the ini file). This can be used for most development stuff. 
	Later, it may have a metadata parser and/or a binary parser. 
-Added config file support for basic engine componenets in EngineImpl.cpp (constructor). 
-Re-organized Object constructor to take unsigned int, this way child objects can use enumerated types, such as the Player object taking in the fighter's enumerated type. Then the Player object itself will handle loading the character etc. 
-I've realized that changing the resolution will cause the sprite sizes to be inaccurate, a very big problem for a fighting game. I've tried using SDL_RenderSetLogicalSize() which is supposed to scale things automatically, but I may have to manually
	add scaling because it might be better in the long run. 
-I think I will just use SDL_RenderSetLogicalSize() for now. Later on, to avoid letterboxing, I can set a base value for each aspect ratio and allow a config file to alter the values. http://en.wikipedia.org/wiki/File:Vector_Video_Standards5.svg
	16:9 (1920x1080) is the most common for steam users so I'm working with that. 

#4/2/14
-Added handleInput to AppState class and implemented it in MenuState (GameState will eventually replace these testing stages). Also added processInput() to Player.
-Each character will have their own x-velocity & y-velocity, and max x-velocity/y-velocity. These are set in the .fighter file and are read as the character is loaded.  
*Note that when adding (velocity * dt) to the player position it must be casted to an int, or strange things happen like moving left is twice as fast. 
-Added basic state machine transitions for walking/blocking. 
-Players flip the rendering direction horizontally based on their playerSide variable. 
-Added Animation class, not complete yet as it's being used for testing in the PlayerImpl object. 
-Added Config::parseAnimation() which will find the x1,y1 and x2,y2 values for the animation (i.e. where it starts and where it ends). Other information can be added
	such as repeats and reversals. 

#4/6/14
-Created Move class (actually, it's a struct for simplicity right now). Each PlayerImpl holds a list of Move objects, which are loaded when they are parsed by the FighterMetadata class, which is derived from Config. 
-I've been recreating the sprite sheet for glacius so that it's even by rectangle-selecting a frame in paint.NET and copying it to a new file. Each frame should overlap adjacent frames to there are no png artifacts in the rendering. 
	It seems the very edges of the png file produce artifacts, so using starting x and y coordinates of 1 solves that problem. 
-Added the ability to reverse an animation, so it can go frames 1-5 for example, and then 5-1 and repeat. I thought this might fix the walking animation but it didn't, it may take something more complex like a sequence of three different repeats. 
	This of course depends on the sprite sheet, really. 

#4/7/14
-Added MessageRouter, which holds a global list of pointers to all Objects in the game (across each state). It is a singleton and allows easy communcation between objects, by using their unique object ID. 
	It is initialized and destroyed in App.cpp.
	In the Object's constructor and destructor, it calls MessageRouter to add/remove the object's pointer.
	It is updated automatically in AppStateManager::start().
-Was having issues with holding both left/right and switching between them--the player state would not update correctly and the walking forward animation would play when walking back and vice versa. 
	Fix by adding another transition for states WALKING_FORWARD (WALK_BACK -> WALKING_BACK) and WALKING_BACK(WALK_FORWARD -> WALKING_FORWARD). I previously thought this would be automatically handled
	when the state machine switched back to IDLE since the IDLE state has proper transitions for WALK_BACK and WALK_FORWARD. So each state will need to be completely transitive. 
	This also fixed the issue when switching sides that involved the player state not updating correctly. 
-Since writing all the code for each state added to the state machine will take much time, I can use macros to shorten the code and automate it as much as possible. 
-Created Server object which sets up a basic UDP socket and listens for incoming UDP packets. Tested with UDP Unicorn and it works. 

#4/9/13
-Created Hitbox class. So far it has intersection functions to detect if it intersects with another hitbox and a static function to detect if two hitboxes intersect.
	It also has a render function which will render the hitbox itself (alpha blended with an outline), which the PlayerImpl class can use to show the hitboxes. 

#4/10/13
-Added ability for the FighterMetadata class to parse hitbox data in each frame section. Also modified Move--Frame is now a struct which holds the rect of the frame
	and all corresponding hitboxes. These are then retrieved in PlayerImpl::updateHitboxes() and rendered in the main loop. PlayerImpl now holds a vector of Hitboxes.
-You can now press R to reload all fighter data, so the .fighter file and be edited and the game will reload it on the fly. 
-My hitbox collision function was for hitbox with their origin at the center, where my hitboxes have a top-left origin, lulz. Must fix now. 
-Used LazyFoo's code for rectangle collision, now it works. 
-PlayerManager::update() is currently handling collisions. It sets the m_colliding flag in PlayerImpl when there is a collision. Then in PlayerImpl::update() the player's	
	x velocity is reversed to the maximum upon collision, causing them to bounce off the other player. 

#4/11/13
-Fixed bug in metadata parser (parseMoveValue()). 
-Changed the way hitboxes are handled in PlayerImpl. 
-Added damage box to the WALKING_FORWARD animation to test it, the PlayerManager detects when it collides with any of the opponent's hitboxes. 

#4/12/13
-Replaced Hitbox::intersects() code with SDL_HasIntersection().

#5/8/13
-The reason FighterMetadata::parseMoveIntValue() returns -1 on failure is to let FighterMetadata::parseMove() know if a frame of animation should be inherited
	from the previous frame, rather than assigning its corresponding value(s) to zero. This will no longer be necessary once a tool is developed to visually 
	edit fighter data. 
-Did some basic cleanup of the code. 

#5/12/14
-When backing up the player's x-velocity is multiplied by 0.85 to reduce the speed and make it more realistic. 
-Removed Background class and replaced it with the more versatile Stage class. It holds a list of StageLayer's which hold a texture and any effect data. The stage layers
	are rendered in order, with layer 1 being behind all succeeding layers. 

#5/13/14
-Added StageManager which is a singleton and keeps stage management more organized and clean. 
-Re-organized PlayerManager to stay consistent with StageManager.
-Added GameState and put all the game code so far into it. MenuState allocates PlayerManager and StageManager, etc. 
-Modified MenuStateImpl's constructor to take a pointer to MenuState, so AppState::pushAppState() and AppState::popAppState() can be accessed from within MenuStateImpl.
	Also had to modify the access of those functions in AppState.hpp from protected to public. This will also be done for succeeding states. 

#5/26/14
-Replaced many uses of const char* in function parameters with const std::string&. I will do this wherever possible to keep the use of std::string consistent. When the time
	comes to integrate other languages this will make it much easier. 
-Added reload() function to PlayerManager and StageManager. 
-Created Camera class which does basic left/right scrolling. It only holds values for where the camera is moving, and StageImpl::update() uses those values to move. 

#5/27/14
-Upgraded to Visual Studio 2013 Ultimate and have C++11. So all std::tr1::shared_ptr<>'s are now std::shared_ptr<>. 
-Put camera movement code in PlayerManager::update(). For now, I will just have to manually check each player according to their side to find out if the camera
	moves. Organizing this in some "correct" manner has proven confusing. 
-Previously the m_colliding value was set to false after collisions were handled in PlayerImpl::update(). It is now reset in PlayerManager::update() right before
	collisions are tested between normal hitboxes. This allows camera movement to be processed for when one player is pushing the other past the edge. 
-Hard coded the starting positions for the players. There is no longer a need for the game.cfg file and it is in the process of being terminated. 
-Also removed network.cfg and just created a [net] section in engine.cfg. 
-In PlayerManager::update(), moved the code to update both players to the beginning of the loop, so that the velocity will be updated before the following code uses it. 
-Got proper camera movement for red player moving left. The blue player's position is manually adjusted in PlayerManager::update() so that he stands still, rather than moving
	with the camera. This may be cheap but it works for now. 

#5/28/14
-Updated Camera class to use proper getter/setter functions. 
-Added PlayerManager::updateCamera() and moved most of the code from update() to it and removed a few unnecessary std::abs() calls. 
-Added Player::toggleDrawHitboxes(). 
-Made the stage start in the exact middle rather than the far right side. 
-The converted project from Visual Studio 2010 was linking very slowly (7-10 seconds). Tried changing many options to no avail. Created a brand new project in 
	Visual Studio 2013 and added all files and builded; now it's extremely fast. Linking time is less than a second.
-Added command line option "/NODEFAULTLIB:msvcrt.lib" in Linker section of project properties. This removed the warning "warning LNK4098: defaultlib 'msvcrt.lib' conflicts with use of other libs; use /NODEFAULTLIB:library"
-So the actual cause of the long linking times was the /FR option being set from generating the dependency graph. It can be disabled by going to Project Properties->C/C++->All Options->Enable Browse Information=No.
	Still, the new 2013 project is much more clean and efficient. 

#5/30/14
-Added GameManager singleton class to manage information across all states. 

#TODO
-Remove c_str() on std::strings where feasible
-Add doxygen to all code and more logging
-When colliding make the forward moving player push the other one into a walking back state
-NET
-LoadResources in Engine
-GUILayer
-For release builds enable code optimization in Project Options->C/C++->Optimization

#Spreadsheet=https://docs.google.com/spreadsheet/ccc?key=0AnnbWNRHDV25dF9SQy1RWXBYdjBqbklNaDN0U2Rwcnc#gid=0



